//Problem link: https://leetcode.com/problems/minimize-malware-spread
//TC: O(N^2)
class DSU{
public:
    vector<int> parent,rank;
    DSU(int n){
        parent.resize(n+1);
        rank.resize(n+1,1);
        for(int i=1;i<=n;i++){
            parent[i]=i;
        }
    }
        int findpar(int u) {
            if(u==parent[u]){
                return u;
            }
            return parent[u] = findpar(parent[u]);
        }
        void unionn(int u,int v){
            u = findpar(u);
            v=findpar(v);
            if(rank[u]>rank[v]){
                parent[v]=u;
            }else if(rank[v]>rank[u]) parent[u]=v;
            else{
                rank[u]++;
                parent[v]=u;
            }
        }
    
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DSU ds(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1 && i!=j){
                    ds.unionn(i,j);
                }
            }
        }

        vector<int> infect(n,0); //infected patient count for each set
        vector<int> popul(n,0); //population of country
        sort(initial.begin(),initial.end());
        int ans = initial[0];
        for(auto it:initial){ //set leader will store how many infected patient there are
            infect[ds.findpar(it)]++;
        }

        for(int i=0;i<n;i++){
            popul[ds.findpar(i)]++;
        }

        int maxpop=0;

        for(auto it:initial){
            //iterating over the leaders and knowing how many infected patients they have
            if(infect[ds.parent[it]]==1 && popul[ds.parent[it]]>maxpop){
                //first we try to remove those that have only 1 infected item in them
                maxpop = popul[ds.parent[it]];
                ans=it;
            }
        }
        return ans;
    }
};
